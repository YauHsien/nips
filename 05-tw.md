NIP-05 中文譯文
==============

Nostr 欄位與 DNS 網路名稱的對照
---------------------------

`最終版` `可選項` `作者:fiatjaf` `作者:mikedilger`

第 `0` 類也就是 `set_metadata` 事件內容可以有 `"nip05"` 欄位，用 [internet identifier](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) email 風格的文字值。但即使所謂 "internet identifier"，NIP-05 只接受本地名稱由不分大小寫的 `a-z0-9-_.` 等符號構成。

客戶端一見到 `"nip05"` 欄位，會將它拆開為本地名稱與領域名稱二個段落。於是，可用 HTTP GET 請求 `https://「領域名稱」/.well-known/nostr.json?name=「本地名稱」`.

其結果須是一份 JSON 文件，裡頭 `"names"` 欄位須是 16 進制數字的 pubkey 的對應名字，寫成字串。如果該名字對得到 `set_metadata` 事件裡的欄位 `pubkey` ，客戶端會總結所給的 pubkey 可對照到 `"nip05"` 網路名稱。

### 例子

如果客戶端看到如下事件：

```json
{
  "pubkey": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9",
  "kind": 0,
  "content": "{\"name\": \"bob\", \"nip05\": \"bob@example.com\"}"
  ...
}
```

它會 GET `https://example.com/.well-known/nostr.json?name=bob` 並獲得下列結果

```json
{
  "names": {
    "bob": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9"
  }
}
````

或者，可能多帶一個 `"relays"` 欄位：

```json
{
  "names": {
    "bob": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9"
  },
  "relays": {
    "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9": [ "wss://relay.example.com", "wss://relay2.example.com" ]
  }
}
````

只要 pubkey 能對照後來如上所述結果的 `"names"` 欄位，則對應成立，並且 `"nip05"` 欄位值有效並適合呈現。

可選用的 `"relays"` 欄位裡，可以有個欄位名稱為 pubkey 值，而欄位值為一列中繼站址。只要有 `"relays"` 欄位，就能幫客戶端多知道一些中繼站。有些網頁伺服器可已根據查詢條件而提供不同的 `/.well-known/nostr.json` 檔案，它也須在同一則回覆查詢裡，盡可能提供該網路名稱的中繼站址。

## 藉由 NIP-05 名稱找人

客戶端可以用 _internet identifiers_ 實作使用者 pubkey 的搜尋比對，流程如以上所述的倒反：首先客戶端取得已知的網址，並由其中可知使用者的公鑰，接著，客戶端試著索取 `0` 事件類型，然後比對看是否符合 `"nip05"` 值。

## 說明

### 客戶端要朝著個人資料的 pubkey 追蹤；不能藉由 NIP-05 標示的地址追蹤對方

例如，假設找到 `bob@bob.com` 的公鑰是 `abc...def`，使用者按下一個按鈕可以追蹤個人資訊，則客戶端須就著 `abc...def` 追蹤，而不是由 `bob@bob.com` 追蹤他。如果網址 `https://bob.com/.well-known/nostr.json?name=bob` 因故改提供另一把公鑰 `1d2...e3f` ，客戶端可不能將原本追蹤對象的公鑰 `abc...def` 換成另一把公鑰 `1d2...e3f`；而客戶端只會認為 "bob@bob.com" 不代表這一位追蹤對象，因為 `"nip05"` 的證明無效。

### 公鑰須以 16 進制數字呈現

公鑰都是以 16 進制數字取得。在 NIP-19 的 `npub` 格式只用來在客戶端的使用者介面上呈現，但在本文 NIP-05 不一樣。

### 個人資料發覺的實作建議

客戶端也可以讓人用 `"nip05"` 來找其他個人資料。如果客戶端提供了搜尋欄位，使用者可以敲 "bob@example.com" 進輸入欄位，客戶端收到之後，做適當的處理，取出 pubkey 而回覆建議給使用者。

### 只顯示領域名稱為識別

客戶端可以將網路名稱用 `_@「領域名稱」` 方式表達領域名稱裡頭的主名稱 ("root")，而要顯示的時候，則只顯示領域名稱。例如，如果 Bob 擁有 `bob.com`，他可能不想要把名字寫成 `bob@bob.com`。則他可以讓名字是 `_@bob.com`，並希望 Nostr 客戶端為一般用途幫他顯示 `bob.com` 為他的名字。

### Reasoning for the `/.well-known/nostr.json?name=<local-part>` format

By adding the `<local-part>` as a query string instead of as part of the path the protocol can support both dynamic servers that can generate JSON on-demand and static servers with a JSON file in it that may contain multiple names.

### Allowing access from JavaScript apps

JavaScript Nostr apps may be restricted by browser [CORS][] policies that prevent them from accessing `/.well-known/nostr.json` on the user's domain. When CORS prevents JS from loading a resource, the JS program sees it as a network failure identical to the resource not existing, so it is not possible for a pure-JS app to tell the user for certain that the failure was caused by a CORS issue. JS Nostr apps that see network failures requesting `/.well-known/nostr.json` files may want to recommend to users that they check the CORS policy of their servers, e.g.:

```bash
$ curl -sI https://example.com/.well-known/nostr.json?name=bob | grep -i ^Access-Control
Access-Control-Allow-Origin: *
```

Users should ensure that their `/.well-known/nostr.json` is served with the HTTP header `Access-Control-Allow-Origin: *` to ensure it can be validated by pure JS apps running in modern browsers.

[CORS]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

### Security Constraints

The `/.well-known/nostr.json` endpoint MUST NOT return any HTTP redirects.

Fetchers MUST ignore any HTTP redirects given by the `/.well-known/nostr.json` endpoint.
