NIP-04 中文譯文
==============

純訊息加密
--------

`最終版` `可選項` `作者:arcbtc`

事件類型 `kind: 4` 是「純訊息加密」；有下列欄位：

**`content`** 須是先由 aes-256-cbc 加密，後經 base 64 編碼的文字。文字內容是使用者想要寫的任何東西。用來加密的密碼是將接收方的公鑰和發送方的私鑰合併為一把密碼，讓收送雙方共享。密文與一段用 base 64 編碼的起始向量合併，後者標示為欄位名稱 "iv" 。所以，格式為 `"content": "「密文」?iv=「起始向量」"`.

**`tags`** 須包含本訊息的接收者，因此，中繼端自然將本訊息傳遞給接收方。格式為 `["p", 「以 16 進制數字表達的 pubkey」]`.

**`tags`** 可包含足以標示先前對話訊息，或我們所指明回覆到的那個訊息。由此可搭建有先後組織關係的對話。格式為 `["e", 「事件 id」]`.

**說明**：依 [libsecp256k1](https://github.com/bitcoin-core/secp256k1) 預定 ECDH 的實作，秘密訊息是共享點位含 X 軸座標與 Y 軸座標的 SHA256 雜湊值。Nostr 只有共享點位的 X 軸座標是秘密訊息，但並不做雜湊。如果使用 libseccp256k1 ，要複製 X 軸座標值並傳入為函數呼叫參數，呼叫函數 `secp256k1_ecdh`，參數名為 `hashfp` 。請參考[這篇](https://github.com/bitcoin-core/secp256k1/blob/master/src/modules/ecdh/main_impl.h#L29)。

用 JavaScript 生成 `kind-4` 事件的例子如下:

```js
import crypto from 'crypto'
import * as secp from 'noble-secp256k1'

let sharedPoint = secp.getSharedSecret(ourPrivateKey, '02' + theirPublicKey)
let sharedX = sharedPoint.substr(2, 64)

let iv = crypto.randomFillSync(new Uint8Array(16))
var cipher = crypto.createCipheriv(
  'aes-256-cbc',
  Buffer.from(sharedX, 'hex'),
  iv
)
let encryptedMessage = cipher.update(text, 'utf8', 'base64')
encryptedMessage += cipher.final('base64')
let ivBase64 = Buffer.from(iv.buffer).toString('base64')

let event = {
  pubkey: ourPubKey,
  created_at: Math.floor(Date.now() / 1000),
  kind: 4,
  tags: [['p', theirPublicKey]],
  content: encryptedMessage + '?iv=' + ivBase64
}
```
